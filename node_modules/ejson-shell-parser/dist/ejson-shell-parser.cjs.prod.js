"use strict";

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var acorn = require("acorn"), bson = require("bson");

function _construct(Parent, args, Class) {
  return (_construct = _isNativeReflectConstruct() ? Reflect.construct : function(Parent, args, Class) {
    var a = [ null ];
    a.push.apply(a, args);
    var instance = new (Function.bind.apply(Parent, a));
    return Class && _setPrototypeOf(instance, Class.prototype), instance;
  }).apply(null, arguments);
}

function _isNativeReflectConstruct() {
  if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
  if (Reflect.construct.sham) return !1;
  if ("function" == typeof Proxy) return !0;
  try {
    return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), 
    !0;
  } catch (e) {
    return !1;
  }
}

function _setPrototypeOf(o, p) {
  return (_setPrototypeOf = Object.setPrototypeOf || function(o, p) {
    return o.__proto__ = p, o;
  })(o, p);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (o) {
    if ("string" == typeof o) return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    return "Object" === n && o.constructor && (n = o.constructor.name), "Map" === n || "Set" === n ? Array.from(o) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(o, minLen) : void 0;
  }
}

function _iterableToArray(iter) {
  if ("undefined" != typeof Symbol && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayLikeToArray(arr, len) {
  (null == len || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function NumberLong(v) {
  return "string" == typeof v ? bson.Long.fromString(v) : bson.Long.fromNumber(v);
}

var SCOPE = {
  RegExp: RegExp,
  Binary: function(buffer, subType) {
    return new bson.Binary(buffer, subType);
  },
  BinData: function(t, d) {
    return new bson.Binary(Buffer.from(d, "base64"), t);
  },
  UUID: function(u) {
    return new bson.Binary(Buffer.from(u.replace(/-/g, ""), "hex"), 4);
  },
  Code: function(c, s) {
    return new bson.Code(c, s);
  },
  DBRef: function(namespace, oid, db, fields) {
    return new bson.DBRef(namespace, oid, db, fields);
  },
  Decimal128: function(s) {
    return bson.Decimal128.fromString(s);
  },
  NumberDecimal: function(s) {
    return bson.Decimal128.fromString(s);
  },
  Double: function(s) {
    return new bson.Double(s);
  },
  Int32: function(i) {
    return new bson.Int32(i);
  },
  NumberInt: function(s) {
    return parseInt(s, 10);
  },
  Long: function(low, high) {
    return new bson.Long(low, high);
  },
  NumberLong: NumberLong,
  Int64: NumberLong,
  Map: function(arr) {
    return new bson.Map(arr);
  },
  MaxKey: function() {
    return new bson.MaxKey;
  },
  MinKey: function() {
    return new bson.MinKey;
  },
  ObjectID: function(i) {
    return new bson.ObjectID(i);
  },
  ObjectId: function(i) {
    return new bson.ObjectID(i);
  },
  Symbol: function(i) {
    return new bson.BSONSymbol(i);
  },
  Timestamp: function(low, high) {
    return new bson.Timestamp(low, high);
  },
  ISODate: function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
    return _construct(Date, _toConsumableArray(args));
  },
  Date: function(_Date) {
    function Date() {
      return _Date.apply(this, arguments);
    }
    return Date.toString = function() {
      return _Date.toString();
    }, Date;
  }((function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
    return _construct(Date, _toConsumableArray(args));
  }))
}, GLOBALS = Object.freeze({
  Infinity: 1 / 0,
  NaN: NaN,
  undefined: void 0
}), ALLOWED_CLASS_EXPRESSIONS = {
  Math: {
    class: Math,
    allowedMethods: {
      abs: !0,
      acos: !0,
      acosh: !0,
      asin: !0,
      asinh: !0,
      atan: !0,
      atan2: !0,
      atanh: !0,
      cbrt: !0,
      ceil: !0,
      clz32: !0,
      cos: !0,
      cosh: !0,
      exp: !0,
      expm1: !0,
      floor: !0,
      fround: !0,
      hypot: !0,
      imul: !0,
      log: !0,
      log10: !0,
      log1p: !0,
      log2: !0,
      max: !0,
      min: !0,
      pow: !0,
      round: !0,
      sign: !0,
      sin: !0,
      sinh: !0,
      sqrt: !0,
      tan: !0,
      tanh: !0,
      trunc: !0
    }
  },
  Date: {
    class: Date,
    allowedMethods: {
      getDate: !0,
      getDay: !0,
      getFullYear: !0,
      getHours: !0,
      getMilliseconds: !0,
      getMinutes: !0,
      getMonth: !0,
      getSeconds: !0,
      getTime: !0,
      getTimezoneOffset: !0,
      getUTCDate: !0,
      getUTCDay: !0,
      getUTCFullYear: !0,
      getUTCHours: !0,
      getUTCMilliseconds: !0,
      getUTCMinutes: !0,
      getUTCMonth: !0,
      getUTCSeconds: !0,
      getYear: !0,
      now: !0,
      setDate: !0,
      setFullYear: !0,
      setHours: !0,
      setMilliseconds: !0,
      setMinutes: !0,
      setMonth: !0,
      setSeconds: !0,
      setTime: !0,
      setUTCDate: !0,
      setUTCFullYear: !0,
      setUTCHours: !0,
      setUTCMilliseconds: !0,
      setUTCMinutes: !0,
      setUTCMonth: !0,
      setUTCSeconds: !0,
      setYear: !0,
      toISOString: !0
    }
  },
  ISODate: {
    class: Date,
    allowedMethods: "Date"
  }
}, GLOBAL_FUNCTIONS = Object.freeze(Object.keys(SCOPE));

function getScopeFunction(key) {
  if (SCOPE[key]) return SCOPE[key];
  throw new Error("Attempted to access scope property '".concat(key, "' that doesn't exist"));
}

function isMethodWhitelisted(member, property) {
  if (ALLOWED_CLASS_EXPRESSIONS[member]) {
    var allowedMethods = ALLOWED_CLASS_EXPRESSIONS[member].allowedMethods;
    return "string" == typeof allowedMethods ? ALLOWED_CLASS_EXPRESSIONS[allowedMethods].allowedMethods[property] : allowedMethods[property];
  }
  return !1;
}

function getClass(member) {
  if (ALLOWED_CLASS_EXPRESSIONS[member]) return ALLOWED_CLASS_EXPRESSIONS[member].class;
  throw new Error("Attempted to access member '".concat(member, "' that doesn't exist"));
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}

function _defineProperty(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value: value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}

var ParseMode, Checker = function Checker(options) {
  var _this = this;
  _classCallCheck(this, Checker), this.options = options, _defineProperty(this, "checkSafeCall", (function(node) {
    var allowMethods = _this.options.allowMethods;
    if ("Identifier" === node.callee.type) return GLOBAL_FUNCTIONS.indexOf(node.callee.name) >= 0 && node.arguments.every(_this.checkSafeExpression);
    if (allowMethods && "MemberExpression" === node.callee.type) {
      var object = node.callee.object, property = node.callee.property;
      return "Identifier" === object.type && "Identifier" === property.type ? isMethodWhitelisted(object.name, property.name) && node.arguments.every(_this.checkSafeExpression) : "NewExpression" !== object.type && "CallExpression" !== object.type || "Identifier" !== object.callee.type ? _this.checkSafeExpression(object) && node.arguments.every(_this.checkSafeExpression) : isMethodWhitelisted(object.callee.name, property.name) && node.arguments.every(_this.checkSafeExpression);
    }
    return !1;
  })), _defineProperty(this, "checkSafeExpression", (function(node) {
    switch (node.type) {
     case "Identifier":
      return GLOBALS.hasOwnProperty(node.name);

     case "Literal":
      return !0;

     case "ArrayExpression":
      return node.elements.every(_this.checkSafeExpression);

     case "UnaryExpression":
      return _this.checkSafeExpression(node.argument);

     case "BinaryExpression":
      return _this.checkSafeExpression(node.left) && _this.checkSafeExpression(node.right);

     case "CallExpression":
     case "NewExpression":
      return _this.checkSafeCall(node);

     case "ObjectExpression":
      return node.properties.every((function(property) {
        return !property.computed && !property.method && (!![ "Literal", "Identifier" ].includes(property.key.type) && _this.checkSafeExpression(property.value));
      }));

     default:
      return !1;
    }
  }));
}, checkTree = function(node, options) {
  if ("Program" === node.type && (1 === node.body.length && "ExpressionStatement" === node.body[0].type)) return new Checker(options).checkSafeExpression(node.body[0].expression);
  return !1;
}, unaryExpression = function(node) {
  if (!node.prefix) throw new Error("Malformed UnaryExpression");
  switch (node.operator) {
   case "-":
    return -walk(node.argument);

   case "+":
    return +walk(node.argument);

   case "!":
    return !walk(node.argument);

   case "~":
    return ~walk(node.argument);

   default:
    throw new Error("Invalid UnaryExpression Provided: '".concat(node.operator, "'"));
  }
}, binaryExpression = function(node) {
  var left = node.left, right = node.right;
  switch (node.operator) {
   case "==":
    return walk(left) == walk(right);

   case "!=":
    return walk(left) != walk(right);

   case "===":
    return walk(left) === walk(right);

   case "!==":
    return walk(left) !== walk(right);

   case "<":
    return walk(left) < walk(right);

   case "<=":
    return walk(left) <= walk(right);

   case ">":
    return walk(left) > walk(right);

   case ">=":
    return walk(left) >= walk(right);

   case "<<":
    return walk(left) << walk(right);

   case ">>":
    return walk(left) >> walk(right);

   case ">>>":
    return walk(left) >>> walk(right);

   case "+":
    return walk(left) + walk(right);

   case "-":
    return walk(left) - walk(right);

   case "*":
    return walk(left) * walk(right);

   case "/":
    return walk(left) / walk(right);

   case "%":
    return walk(left) % walk(right);

   case "**":
    return Math.pow(walk(left), walk(right));

   case "|":
    return walk(left) | walk(right);

   case "^":
    return walk(left) ^ walk(right);

   case "&":
    return walk(left) & walk(right);

   case "in":
    return walk(left) in walk(right);

   case "instanceof":
    return walk(left) instanceof walk(right);

   default:
    throw new Error("Invalid BinaryExpression Provided: '".concat(node.operator, "'"));
  }
}, memberExpression = function(node) {
  switch (node.callee.type) {
   case "Identifier":
    var callee = getScopeFunction(node.callee.name), args = node.arguments.map((function(arg) {
      return walk(arg);
    }));
    return callee.apply(callee, args);

   case "MemberExpression":
    var calleeThis = "Identifier" === node.callee.object.type ? getClass(node.callee.object.name) : walk(node.callee.object), calleeFn = "Identifier" === node.callee.property.type && node.callee.property.name;
    if (!calleeFn) throw new Error("Expected CallExpression property to be an identifier");
    var _args = node.arguments.map((function(arg) {
      return walk(arg);
    }));
    return calleeThis[calleeFn].apply(calleeThis, _args);

   default:
    throw new Error("Should not evaluate invalid expressions");
  }
}, walk = function walk(node) {
  switch (node.type) {
   case "Identifier":
    if (GLOBALS.hasOwnProperty(node.name)) return GLOBALS[node.name];
    throw new Error("".concat(node.name, " is not a valid Identifier"));

   case "Literal":
    return node.value;

   case "UnaryExpression":
    return unaryExpression(node);

   case "BinaryExpression":
    return binaryExpression(node);

   case "ArrayExpression":
    return node.elements.map((function(node) {
      return walk(node);
    }));

   case "CallExpression":
   case "NewExpression":
    return memberExpression(node);

   case "ObjectExpression":
    var obj = {};
    return node.properties.forEach((function(property) {
      var key = "Identifier" === property.key.type ? property.key.name : walk(property.key);
      obj[key] = walk(property.value);
    })), obj;

   default:
    throw new Error;
  }
}, executeAST = function(node) {
  if ("Program" === node.type && 1 === node.body.length && "ExpressionStatement" === node.body[0].type) return walk(node.body[0].expression);
  throw new Error("Invalid AST Found");
};

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty$1(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

function _defineProperty$1(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value: value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}

!function(ParseMode) {
  ParseMode.Strict = "strict", ParseMode.Extended = "extended", ParseMode.Loose = "loose";
}(ParseMode || (ParseMode = {}));

var StrictOptions = {
  allowMethods: !1,
  allowComments: !1
}, ExtendedOptions = {
  allowMethods: !0
}, LooseOptions = {
  allowMethods: !0,
  allowComments: !0
};

function getModeOptions(mode) {
  switch (mode) {
   case ParseMode.Strict:
    return StrictOptions;

   case ParseMode.Extended:
    return ExtendedOptions;

   case ParseMode.Loose:
    return LooseOptions;
  }
}

var DefaultOptions = _objectSpread({
  mode: ParseMode.Strict
}, StrictOptions);

function buildOptions(options) {
  return _objectSpread(_objectSpread(_objectSpread({}, DefaultOptions), getModeOptions(options && options.mode || ParseMode.Strict)), options);
}

function buildAST(input) {
  var hasComments = !1;
  return {
    ast: acorn.parse(input, {
      ecmaVersion: 5,
      onComment: function() {
        return hasComments = !0;
      }
    }),
    hasComments: hasComments
  };
}

function parse(input, options) {
  var parsedOptions = buildOptions(options), _buildAST = buildAST("(".concat(input, ")")), hasComments = _buildAST.hasComments, ast = _buildAST.ast;
  return (!hasComments || parsedOptions.allowComments) && checkTree(ast, parsedOptions) ? executeAST(ast) : "";
}

exports.default = parse;
